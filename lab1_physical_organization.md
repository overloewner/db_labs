# Лабораторная работа №1: Физическая организация данных в PostgreSQL

## Краткая последовательность команд

```sql
-- 1. Подключение к PostgreSQL
psql -U postgres

-- 2. Создание базы данных
CREATE DATABASE lab1_storage;
\c lab1_storage

-- 3. Проверка директории данных
SHOW data_directory;

-- 4. Просмотр табличных пространств
SELECT oid, spcname FROM pg_tablespace;

-- 5. Создание директории для табличного пространства (из shell)
-- mkdir -p /tmp/tablespace_demo
-- chown postgres:postgres /tmp/tablespace_demo

-- 6. Создание табличного пространства
CREATE TABLESPACE demo_space LOCATION '/tmp/tablespace_demo';

-- 7. Создание таблицы в новом табличном пространстве
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    description TEXT
) TABLESPACE demo_space;

-- 8. Вставка данных с большим текстом (для демонстрации TOAST)
INSERT INTO products (name, description)
VALUES ('Product1', repeat('Large text ', 10000));

-- 9. Просмотр размера таблицы
SELECT pg_size_pretty(pg_total_relation_size('products')) as total_size,
       pg_size_pretty(pg_relation_size('products')) as main_size,
       pg_size_pretty(pg_total_relation_size('products') - pg_relation_size('products')) as external_size;

-- 10. Просмотр файлов таблицы
SELECT pg_relation_filepath('products');

-- 11. Просмотр TOAST-таблицы
SELECT relname, reltoastrelid
FROM pg_class
WHERE relname = 'products';

-- 12. Создание таблицы в табличном пространстве по умолчанию
SET default_tablespace = demo_space;
CREATE TABLE orders (id SERIAL, product_id INT);

-- 13. Просмотр всех объектов в табличном пространстве
SELECT c.relname, t.spcname
FROM pg_class c
JOIN pg_tablespace t ON c.reltablespace = t.oid
WHERE t.spcname = 'demo_space';
```

---

## Подробное объяснение команд

### 1. Подключение к PostgreSQL

```bash
psql -U postgres
```

**Что делает:** Запускает интерактивный терминал PostgreSQL от имени пользователя `postgres` (суперпользователь по умолчанию).

**Параметры:**
- `-U postgres` — указывает имя пользователя для подключения

---

### 2. Создание базы данных

```sql
CREATE DATABASE lab1_storage;
\c lab1_storage
```

**Что делает:**
- `CREATE DATABASE` создает новую базу данных с именем `lab1_storage`
- `\c lab1_storage` — мета-команда psql для переключения на созданную базу данных

**Результат:** База данных создана и установлено подключение к ней.

---

### 3. Проверка директории данных

```sql
SHOW data_directory;
```

**Что делает:** Выводит путь к основной директории, где PostgreSQL хранит все файлы кластера баз данных.

**Вывод (пример):**
```
        data_directory
------------------------------
 /var/lib/postgresql/14/main
```

**Объяснение колонок:**
- `data_directory` — абсолютный путь к каталогу данных PostgreSQL, где хранятся все файлы баз данных, конфигурации, журналы WAL и системные каталоги

**Концепция:** Физически все данные PostgreSQL хранятся в файловой системе. Эта директория содержит поддиректории для каждой базы данных, табличных пространств, журналов транзакций (WAL) и конфигурационных файлов.

---

### 4. Просмотр табличных пространств

```sql
SELECT oid, spcname FROM pg_tablespace;
```

**Что делает:** Запрашивает системный каталог `pg_tablespace` для получения списка всех табличных пространств в кластере.

**Вывод (пример):**
```
  oid  |  spcname
-------+------------
  1663 | pg_default
  1664 | pg_global
```

**Объяснение колонок:**
- `oid` — уникальный идентификатор объекта (Object ID) табличного пространства в системе
- `spcname` — имя табличного пространства

**Системные табличные пространства:**
- `pg_default` — используется по умолчанию для всех пользовательских баз данных
- `pg_global` — используется для системных каталогов, общих для всего кластера

**Концепция:** Табличное пространство — это физическое место хранения на диске. Позволяет администратору размещать данные на разных дисках для оптимизации производительности или управления дисковым пространством.

---

### 5. Создание директории для табличного пространства

```bash
mkdir -p /tmp/tablespace_demo
chown postgres:postgres /tmp/tablespace_demo
```

**Что делает:**
- `mkdir -p` создает директорию (флаг `-p` создает родительские директории при необходимости)
- `chown` устанавливает владельца директории на пользователя и группу `postgres`

**Важно:** PostgreSQL требует, чтобы директория существовала, была пустой и принадлежала пользователю PostgreSQL до создания табличного пространства.

---

### 6. Создание табличного пространства

```sql
CREATE TABLESPACE demo_space LOCATION '/tmp/tablespace_demo';
```

**Что делает:** Регистрирует новое табличное пространство в кластере PostgreSQL с указанием физического расположения в файловой системе.

**Параметры:**
- `demo_space` — имя табличного пространства
- `LOCATION '/tmp/tablespace_demo'` — абсолютный путь к директории

**Результат:** Создается символическая ссылка из `$PGDATA/pg_tblspc/` на указанную директорию, и табличное пространство становится доступным для использования.

**Концепция:** Табличные пространства позволяют:
- Размещать данные на разных физических дисках
- Оптимизировать производительность (быстрые диски для индексов, медленные для архивов)
- Управлять дисковым пространством

---

### 7. Создание таблицы в новом табличном пространстве

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    description TEXT
) TABLESPACE demo_space;
```

**Что делает:** Создает таблицу `products` и размещает её файлы в табличном пространстве `demo_space`.

**Структура таблицы:**
- `id SERIAL PRIMARY KEY` — автоинкрементный первичный ключ
- `name VARCHAR(100)` — строка ограниченной длины
- `description TEXT` — текстовое поле неограниченной длины
- `TABLESPACE demo_space` — явное указание табличного пространства

**Концепция:** Без указания `TABLESPACE` таблица была бы создана в табличном пространстве по умолчанию (`pg_default`).

---

### 8. Вставка данных с большим текстом

```sql
INSERT INTO products (name, description)
VALUES ('Product1', repeat('Large text ', 10000));
```

**Что делает:** Вставляет строку с очень большим текстовым полем (примерно 110KB).

**Функция:**
- `repeat('Large text ', 10000)` — повторяет строку 10000 раз

**Концепция TOAST:** PostgreSQL имеет ограничение на размер страницы (обычно 8KB). Большие значения автоматически сжимаются и/или выносятся в отдельную TOAST-таблицу (The Oversized-Attribute Storage Technique). Это происходит прозрачно для пользователя.

---

### 9. Просмотр размера таблицы

```sql
SELECT pg_size_pretty(pg_total_relation_size('products')) as total_size,
       pg_size_pretty(pg_relation_size('products')) as main_size,
       pg_size_pretty(pg_total_relation_size('products') - pg_relation_size('products')) as external_size;
```

**Что делает:** Вычисляет и отображает размеры таблицы в человекочитаемом формате.

**Вывод (пример):**
```
 total_size | main_size | external_size
------------+-----------+---------------
 128 kB     | 8192 bytes| 120 kB
```

**Объяснение колонок:**
- `total_size` — общий размер таблицы, включая TOAST, индексы и другие связанные данные
- `main_size` — размер только основной таблицы (без TOAST и индексов)
- `external_size` — размер данных в TOAST-таблице и индексах

**Функции:**
- `pg_total_relation_size()` — возвращает полный размер таблицы в байтах
- `pg_relation_size()` — возвращает размер только основной части таблицы
- `pg_size_pretty()` — форматирует байты в KB/MB/GB

**Концепция:** Видно, что большая часть данных (external_size) хранится в TOAST-таблице, а не в основной таблице.

---

### 10. Просмотр файлов таблицы

```sql
SELECT pg_relation_filepath('products');
```

**Что делает:** Возвращает путь к файлу таблицы относительно директории данных.

**Вывод (пример):**
```
     pg_relation_filepath
------------------------------
 pg_tblspc/16384/PG_14_202107181/16385/16389
```

**Объяснение пути:**
- `pg_tblspc/16384` — символическая ссылка на табличное пространство (OID 16384)
- `PG_14_202107181` — версия PostgreSQL и идентификатор совместимости
- `16385` — OID базы данных
- `16389` — OID таблицы (relfilenode)

**Концепция:** Каждая таблица хранится в одном или нескольких файлах по 1GB. PostgreSQL использует OID для именования файлов, а не человекочитаемые имена.

---

### 11. Просмотр TOAST-таблицы

```sql
SELECT relname, reltoastrelid
FROM pg_class
WHERE relname = 'products';
```

**Что делает:** Запрашивает информацию о TOAST-таблице, связанной с таблицей `products`.

**Вывод (пример):**
```
 relname  | reltoastrelid
----------+---------------
 products |         16392
```

**Объяснение колонок:**
- `relname` — имя таблицы
- `reltoastrelid` — OID связанной TOAST-таблицы (0 если TOAST не используется)

**Концепция:** Если значение не равно 0, значит PostgreSQL создал отдельную TOAST-таблицу для хранения больших значений. TOAST-таблица имеет имя вида `pg_toast_<OID>`.

---

### 12. Установка табличного пространства по умолчанию

```sql
SET default_tablespace = demo_space;
CREATE TABLE orders (id SERIAL, product_id INT);
```

**Что делает:**
- `SET default_tablespace` устанавливает табличное пространство по умолчанию для текущей сессии
- Новые таблицы будут создаваться в `demo_space` без явного указания `TABLESPACE`

**Концепция:** Это удобный способ создавать множество объектов в одном табличном пространстве без явного указания в каждой команде.

---

### 13. Просмотр всех объектов в табличном пространстве

```sql
SELECT c.relname, t.spcname
FROM pg_class c
JOIN pg_tablespace t ON c.reltablespace = t.oid
WHERE t.spcname = 'demo_space';
```

**Что делает:** Выводит список всех объектов (таблиц, индексов), размещенных в табличном пространстве `demo_space`.

**Вывод (пример):**
```
  relname  |   spcname
-----------+-------------
 products  | demo_space
 orders    | demo_space
```

**Объяснение колонок:**
- `relname` — имя объекта (таблицы, индекса и т.д.)
- `spcname` — имя табличного пространства

**Системные каталоги:**
- `pg_class` — содержит информацию о всех таблицах, индексах, последовательностях и других объектах
- `pg_tablespace` — содержит информацию о табличных пространствах

**Концепция:** Позволяет администратору контролировать, какие объекты размещены на каких дисках/разделах.

---

## Технический концепт: Физическая организация данных

### Иерархия хранения в PostgreSQL

1. **Кластер** — совокупность баз данных, управляемых одним экземпляром сервера
2. **База данных** — логическая группа схем и объектов
3. **Схема** — пространство имен внутри базы данных
4. **Таблица** — основная единица хранения данных
5. **Страница (Page)** — минимальная единица ввода-вывода (обычно 8KB)
6. **Строка (Tuple)** — отдельная запись в таблице

### Табличные пространства: применение

- **Разделение нагрузки:** Размещение таблиц и индексов на разных дисках для параллельного доступа
- **Производительность:** Быстрые SSD для горячих данных, медленные HDD для архивов
- **Управление пространством:** Расширение хранилища без переконфигурирования основного раздела
- **Изоляция:** Критичные данные на отдельных надежных дисках

### TOAST: механизм хранения больших значений

PostgreSQL использует **TOAST (The Oversized-Attribute Storage Technique)** для хранения больших значений:

- **Автоматическое сжатие:** Значения сжимаются алгоритмом LZ перед хранением
- **Внешнее хранение:** Если после сжатия значение все еще велико (>~2KB), оно выносится в отдельную TOAST-таблицу
- **Прозрачность:** Приложения не замечают использование TOAST
- **Оптимизация:** При чтении строки TOAST-данные загружаются только при необходимости

### Ограничения размеров

- **Максимальный размер БД:** ограничен файловой системой (обычно терабайты)
- **Максимальный размер таблицы:** 32 TB
- **Максимальный размер строки:** ~1.6 TB (с TOAST)
- **Максимальный размер поля:** 1 GB (без TOAST ~400 MB)
- **Максимальное количество столбцов:** 250-1600 (зависит от типов)

### Практическое применение

**Сценарий 1:** Интернет-магазин с большой таблицей заказов
- Старые заказы → медленное табличное пространство на HDD
- Текущие заказы → быстрое табличное пространство на SSD
- Индексы по датам → отдельное табличное пространство

**Сценарий 2:** Хранилище документов
- Метаданные документов → основное табличное пространство
- Содержимое документов (TEXT/BYTEA) → автоматически уходит в TOAST
- Полнотекстовые индексы → отдельное быстрое табличное пространство

**Сценарий 3:** Управление дисковым пространством
- Основной раздел заполнился → создать новое табличное пространство на другом диске
- Переместить крупные таблицы: `ALTER TABLE big_table SET TABLESPACE new_space;`
